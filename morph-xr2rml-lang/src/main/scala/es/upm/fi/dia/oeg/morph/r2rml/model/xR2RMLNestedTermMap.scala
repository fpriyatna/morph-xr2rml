package es.upm.fi.dia.oeg.morph.r2rml.model

import org.apache.log4j.Logger
import es.upm.fi.dia.oeg.morph.base.{Constants, TemplateUtility}
import com.hp.hpl.jena.rdf.model.RDFNode
import com.hp.hpl.jena.rdf.model.Resource
import es.upm.fi.dia.oeg.morph.base.exception.MorphException
import es.upm.fi.dia.oeg.morph.base.path.MixedSyntaxPath

/**
  * @todo This class is only a partial implementation of xR2RML nested term maps: it only support simple nested term maps,
  * i.e. without any xrr:reference, rr:template nor xrr:nestedTermMap property.
  * It can be used only to qualify terms of an RDF collection or container generated by the parent term map.
  *
  * @author Franck Michel, I3S laboratory
  */
class xR2RMLNestedTermMap(
                                   /** Type of the root parent term map, used to infer the term type if it is not provided explicitly */
                                   parentTermMapType: Constants.MorphTermMapType.Value,
                                   override val termMapType: Constants.MorphTermMapType.Value,
                                   override val termType: Option[String],
                                   override val datatype: Option[String],
                                   override val languageTag: Option[String],
                                   override val nestedTermMap: Option[xR2RMLNestedTermMap],
                                   override val refFormulation: String
                                 )
  extends AbstractTermMap(termMapType, termType, datatype, languageTag, nestedTermMap, refFormulation) {
  override val logger = Logger.getLogger(this.getClass().getName());


  //var referenceFormulation:String = null;

  //var reference:String = null;

  //var templateString:String = null;

  //var constantValue:String = null;

  //logger.info("nested term map type = " + nestedTermMapType);

  override def toString(): String = {
    "NestedTermMap[termType:" + termType + ", datatype:" + datatype + ", language:" + languageTag + "]";
  }

  //	override def getReferenceFormulation() : String = { this.refFormulation }

  //override def getConstantValue(): String = this.constantValue;

  //override def getReference(): String = this.reference

  //override def getTemplateString():String = this.templateString;



  /**
    * Return true if the nested term map has no xrr:reference nor rr:template property
    */
  def isSimpleNestedTermMap = { !isReferenceValued && !isTemplateValued }

  //	/**
  //		* Return the term type mentioned by property rr:termType or the default term type otherwise
  //		*/
  //	def inferTermType: String = {
  //		this.termType.getOrElse(this.getDefaultTermType)
  //	}
  //
  //	def getDefaultTermType: String = {
  //		parentTermMapType match {
  //			case Constants.MorphTermMapType.ColumnTermMap => Constants.R2RML_LITERAL_URI
  //			case Constants.MorphTermMapType.ReferenceTermMap => Constants.R2RML_LITERAL_URI
  //			case Constants.MorphTermMapType.TemplateTermMap => Constants.R2RML_IRI_URI
  //			case _ => Constants.R2RML_LITERAL_URI
  //		}
  //	}

  //	/**
  //		* Return true if the term type's term map is one of RDF list, bag, seq, alt
  //		*/
  //	def isRdfCollectionTermType: Boolean = {
  //		this.isRdfCollectionTermType(termType)
  //	}


}

object xR2RMLNestedTermMap {
  val logger = Logger.getLogger(this.getClass().getName());


  /**
    * Deduce the type of the nested term map (simple, reference, template) based on its properties
    * @param rdfNode the nested term map node
    * @throws es.upm.fi.dia.oeg.morph.base.exception.MorphException in case the nested term map type cannot be decided
    */
  def extractNestedTermMapType(rdfNode: RDFNode) = {
    rdfNode match {
      case resource: Resource => {
        val templateStmt = resource.getProperty(Constants.R2RML_TEMPLATE_PROPERTY);
        val referenceStmt = resource.getProperty(Constants.xR2RML_REFERENCE_PROPERTY);


        if (templateStmt != null && referenceStmt == null) Constants.MorphTermMapType.TemplateTermMap;
        else if (referenceStmt != null && templateStmt == null) Constants.MorphTermMapType.ReferenceTermMap;
        else if (referenceStmt == null && templateStmt == null) Constants.MorphTermMapType.SimpleNestedTermMap;
        else {
          val errorMessage = "Invalid nested term map " + resource.getLocalName() + ". Should be either template or reference or simple";
          logger.error(errorMessage);
          throw new MorphException(errorMessage);
        }
      }
      case _ => {
        val errorMessage = "Invalid nested term map. Should be either template or reference or simple";
        logger.error(errorMessage);
        throw new MorphException(errorMessage);
      }
    }
  }

  /**
    * Look for a xrr:nestedTermMap property and creates an instance of xR2RMLNestedTermMap.
    *
    * LIMITATION: only the term type, datatype and language tag are supported for now.
    * No reference or template nor further nested term map is supported.
    * @todo implement the full support of nested term maps
    */
  def extractNestedTermMap(parentTermMapType: Constants.MorphTermMapType.Value, rdfNode: RDFNode,
                           refFormulation: String): Option[xR2RMLNestedTermMap] = {
    rdfNode match {
      case resource: Resource => {
        var ntmStmt = resource.getProperty(Constants.xR2RML_NESTEDTM_PROPERTY);
        if ((ntmStmt != null) && ntmStmt.getObject.isResource) {
          val ntmRes:Resource = ntmStmt.getObject.asResource
          val termTypeStmt = ntmRes.getProperty(Constants.R2RML_TERMTYPE_PROPERTY)
          val datatypeStmt = ntmRes.getProperty(Constants.R2RML_DATATYPE_PROPERTY)
          val langStmt = ntmRes.getProperty(Constants.R2RML_LANGUAGE_PROPERTY)
          val referenceStmt = ntmRes.getProperty(Constants.xR2RML_REFERENCE_PROPERTY)
          val templateStmt = ntmRes.getProperty(Constants.R2RML_TEMPLATE_PROPERTY)

          val termType = if (termTypeStmt == null) None else Some(termTypeStmt.getObject().toString())
          val datatype = if (datatypeStmt == null) None else Some(datatypeStmt.getObject().toString())
          val language = if (langStmt == null) None else Some(langStmt.getObject().toString())

          val nestedTermMapType = xR2RMLNestedTermMap.extractNestedTermMapType(ntmRes)


          val ntm = new xR2RMLNestedTermMap(parentTermMapType, nestedTermMapType, termType, datatype, language, None,
            refFormulation);
          ntm.parse(ntmRes);
          Some(ntm)
        } else None
      }
      case _ => { None }
    }
  }
}
