package es.upm.fi.dia.oeg.morph.r2rml.model

import org.apache.log4j.Logger
import es.upm.fi.dia.oeg.morph.base.{Constants, TemplateUtility}
import com.hp.hpl.jena.rdf.model.RDFNode
import com.hp.hpl.jena.rdf.model.Resource
import es.upm.fi.dia.oeg.morph.base.exception.MorphException
import es.upm.fi.dia.oeg.morph.base.path.MixedSyntaxPath

/**
	* @todo This class is only a partial implementation of xR2RML nested term maps: it only support simple nested term maps,
	* i.e. without any xrr:reference, rr:template nor xrr:nestedTermMap property.
	* It can be used only to qualify terms of an RDF collection or container generated by the parent term map.
	*
	* @author Franck Michel, I3S laboratory
	*/
class xR2RMLNestedTermMap(
													 /** Type of the root parent term map, used to infer the term type if it is not provided explicitly */
													 parentTermMapType: Constants.MorphTermMapType.Value,
													 override val termMapType: Constants.MorphTermMapType.Value,
													 override val termType: Option[String],
													 override val datatype: Option[String],
													 override val languageTag: Option[String],
													 override val nestedTermMap: Option[xR2RMLNestedTermMap]
												 ) extends AbstractTermMap(termMapType, termType, datatype, languageTag, nestedTermMap) {

	var referenceFormulation:String = null;

	var reference:String = null;

	var templateString:String = null;

	var constantValue:String = null;

	override val logger = Logger.getLogger(this.getClass().getName());
	//logger.info("nested term map type = " + nestedTermMapType);

	override def toString(): String = {
		"NestedTermMap[termType:" + termType + ", datatype:" + datatype + ", language:" + languageTag + "]";
	}

	override def getReferenceFormulation() : String = { this.referenceFormulation }

	override def getConstantValue(): String = this.constantValue;

	override def getReference(): String = this.reference

	override def getTemplateString():String = this.templateString;



	/**
		* Return true if the nested term map has no xrr:reference nor rr:template property
		*/
	def isSimpleNestedTermMap = { !isReferenceValued && !isTemplateValued }

//	/**
//		* Return the term type mentioned by property rr:termType or the default term type otherwise
//		*/
//	def inferTermType: String = {
//		this.termType.getOrElse(this.getDefaultTermType)
//	}
//
//	def getDefaultTermType: String = {
//		parentTermMapType match {
//			case Constants.MorphTermMapType.ColumnTermMap => Constants.R2RML_LITERAL_URI
//			case Constants.MorphTermMapType.ReferenceTermMap => Constants.R2RML_LITERAL_URI
//			case Constants.MorphTermMapType.TemplateTermMap => Constants.R2RML_IRI_URI
//			case _ => Constants.R2RML_LITERAL_URI
//		}
//	}

//	/**
//		* Return true if the term type's term map is one of RDF list, bag, seq, alt
//		*/
//	def isRdfCollectionTermType: Boolean = {
//		this.isRdfCollectionTermType(termType)
//	}


}

object xR2RMLNestedTermMap {
	val logger = Logger.getLogger(this.getClass().getName());


	/**
		* Deduce the type of the nested term map (simple, reference, template) based on its properties
		* @param rdfNode the nested term map node
		* @throws es.upm.fi.dia.oeg.morph.base.exception.MorphException in case the nested term map type cannot be decided
		*/
	def extractNestedTermMapType(rdfNode: RDFNode) = {
		rdfNode match {
			case resource: Resource => {
				val templateStmt = resource.getProperty(Constants.R2RML_TEMPLATE_PROPERTY);
				val referenceStmt = resource.getProperty(Constants.xR2RML_REFERENCE_PROPERTY);

				if (templateStmt != null && referenceStmt == null) Constants.MorphTermMapType.TemplateTermMap;
				else if (referenceStmt != null && templateStmt == null) Constants.MorphTermMapType.ReferenceTermMap;
				else {
					val errorMessage = "Invalid nested term map " + resource.getLocalName() + ". Should be either template or reference or simple";
					logger.error(errorMessage);
					throw new MorphException(errorMessage);
				}
			}
			case _ => {
				val errorMessage = "Invalid nested term map. Should be either template or reference or simple";
				logger.error(errorMessage);
				throw new MorphException(errorMessage);
			}
		}
	}
}
